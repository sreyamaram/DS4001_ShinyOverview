---
title: "Shiny Overview"
author: Sreya Maram, Danielle Parks, Shaira Suhrat
date: 10/08/2020
output: rmdformats::readthedown
html_document:
  toc: TRUE
  toc_float: TRUE
  toc_depth: 2
  number_sections: true
  self_contained: true
  thumbnails: true
  lightbox: true
  gallery: false
  highlight: tango
runtime: shiny   
---

```{r setup, include=FALSE, results='hide', message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(shiny)
```

## Package Overview
Shiny is an open source R package that simplifies building interactive web applications directly from R. It allows users to translate their analyses to interactive web applications without requiring HTML, CSS, or JavaScript knowledge. You can also extend your Shiny apps with CSS themes, htmlwidgets, and JavaScript actions.

```{r, fig.align='right', fig.cap="Shiny", echo=FALSE}
knitr::include_graphics('Shiny_logo.jpg')
```


## Background 
Joe Cheng, the current chief of technology officer at Rstudio, created the shiny web framework in 2012. Intended to be used as a tool for production, earlier versions of shiny were limited to educational settings for teaching and demonstrations. Over time, through numerous developments, shiny evolved from a simple system manually maintained on two Amazon AWS servers to one of the most popular packages in R today. 

## Version History
The latest version of Shiny is v 1.5; released in June 23, 2020.

The earliest version available on Github is v 0.3, which dates back to March 1, 2013.


## Usage
Shiny has built-in support for interacting with static plots generated by R’s base[{}] graphics functions, and those generated by ggplot2. This makes it easy to add features like selecting points and regions, as well as zooming in and out of images.

Shiny allows users to create interactive web pages directly from R.
Users can create:

  - Standalone apps

  - Interactive documents

  - Dashboards

  - Gadgets

Shiny creates interactive web pages using a reactive programming model.


## Dependency 
R (≥ 3.0.2), methods (for v 1.5)



## Code Exploration

Shiny apps have three components:

  1) A User interface object which dictates the layout and appearance of the app.
  2) A Server function contains the instructions on how to output and run what you defined in the UI object.
  3) A call to the shinyApp function which creates a Shiny app object from the UI/server pair you created.


### User Interface Object

**fluidPage**  takes in the elements you want to place into your user's browser output, such as **titlePanel()** and **sidebarLayout()** which is used in this case. **fluidPage** creates a display that automatically adjusts to the dimensions of your browser window. 

**sidebarLayout()**  always takes two arguments, **sidebarPanel()**  and **mainPanel()**. Other visual elements and features can be passed into these panels, which create a basic structure on the ShinyApp.

HTML output can be displayed in Shiny by encoding it into any "Panel" function. 
In example 1 below, these are all used to customize text output:

*  **p()**	A paragraph of text
* **h4()**	A fourth level header
*  **h5()**	A fifth level header
*  **br()**	A line break (e.g. a blank line)
*  **strong()**	Bold text
*  **em()**	Italicized text
*  **span()**	A division that formats all the text in one line with a uniform style
  
Other elements such as images, hyperlinks, and more text formats could be passed in and added as well. 

To move into the interactive side of Shiny apps, your UI can take in **control widgets**, which collects a value/input from the user. When the user interacts with the widget, their input will be reflected in the server in the manner you choose. 

Shiny provides many standard widgets but these are used below in example 1:

  **textInput()**	A field to enter text entered by user.
  **selectInput()**	A box with choices to select from specified by user.
  
All widgets take in a label but have other arguments based on their purpose. 


### Server Functions
In order to incorporate the "live" quality into Shiny, there are a family of functions that take in user input and create output for your user interface browser. These functions can be added to Panel functions, just like any visual elements. 

In the examples below, these output functions are used: 

* **plotOutput()**	outputs a plot
* **textOutput()**	ouputs text
* **uiOutput()**	outputs raw HTML


Placing a function in UI tells Shiny where and how to display your object. But you need to tell Shiny how to build the object. This is done through the  **server()** function.

The server builds an object named output that includes instructions on how to update and display R objects in your app. Each R object gets its own **output** entry and it should match the name of the reactive element you made in the UI.

Every output entry is connected to one of Shiny’s **render** functions, which incorporates your R object and then does some of the groundwork and pre-processing to properly display and update your output. 

The render* functions corresponds to the type of reactive object you are creating, and these are used in the examples below:

* **renderPlot()**	creates and formats plots
* **renderText()**	displays character strings
* **renderUI()**	  displays Shiny tag object or HTML

Text, plots, data tables, HTML code, print text etc. can all be made reactive by asking Shiny to call a widget value when it builds the output. The **server()** function takes both **input** and **output** arguments. 
While output is object that stores instructions for building the R objects, input stores the current values collected from all your widgets. 


When you are finally ready, you can launch your app with the **ShinyApp()** function, which takes in UI and server arguments and requires you to match the right ones. Other similar functions like **runApp()** can also be used to launch Shiny applications. 


## Example 1
```{r}
# Define UI ----
ui1 <- fluidPage(
  titlePanel(code("Hello! Let's look at some data science quotes.")),
  sidebarLayout(
    sidebarPanel(
      
      # heading text
      h4("Customize your quote."),
      
      #widget that simply displays a block of text
      helpText("Select these attributes to format your text."),
      
      ##text input control widgets
      textInput("quote", label = "Enter a short quote here", value = ""),
      textInput("name", label = "Enter your name", value = ""),
      
      #drop down menu control widgets 
      selectInput("font", 
                  label = "Select a font for your text.",
                  choices = list( "font-family: 'Arial'", 
                                  "font-family: 'Times'",
                                  "font-family: 'Courier'"),
                  selected = " "),
      selectInput("color", 
                  label = "Select a color for your text.",
                  choices = list( "color:black",
                                  "color:blue", 
                                  "color:red",
                                  "color:green",
                                  "color:yellow",
                                  "color:orange"),
                  selected = " "),
    ),
    mainPanel(
      
      ## visual text HTML elements 
      h5(strong("The world is one big data problem.")),
      p(em(" -Andrew McAffee")),
      h5(strong("Without data you're just another person with an opinion.")),
      p(em(" -W. Edwards Deming")),
      h5(strong("The problem isn't finding data, it's figuring out what to do with it.")),
      p(em(" -Mike Loukides")),
      br(),
      h4("View your quote here."),
      
      ##functions used to display output, e.g. HTML elements 
      uiOutput("entered_quote"),
      uiOutput("entered_name"),
    )
  )
)

```



### Server Logic
```{r}
# Define server logic ----
server1 <- function(input, output) {
  
  #renders the HTML text and updates it according to user input through widgets 
  output$entered_quote <- renderUI({
    message <- h5(strong(input$quote, style = input$font))
    span(message, style = input$color)
  })
  output$entered_name <- renderUI({ 
    p(em(" -", input$name))
  })
}
```


### Run the App
```{r}
shinyApp(ui = ui1, server = server1)
```


## Example 2

### Data Processing 
```{r results='hide', message=FALSE, warning=FALSE}

library(ggplot2)
library(tidyverse)
library(dslabs)

disease_data <- us_contagious_diseases 
disease_data <- (disease_data <-  disease_data %>% group_by(disease, state)) %>%
  summarize(total_count = sum(count))

```


### UI 
```{r}
ui2 <- fluidPage(
  
  titlePanel("US Contagious Disease Data from 1928 to 2011 "),
  sidebarLayout(
    sidebarPanel(
      helpText("Select the variables to view in your visualization."),
      textInput("state", label = "Enter a state here", value = "Alabama"),
      
      ##control widget with a range of values with a single slider value 
      sliderInput("count", label = "Choose a minimum case count.", min = 0, 
                  max = 2000000, value = 0),
    ),
    mainPanel(
      #function that will output a plot in the UI
      plotOutput("diseasePlot")
    )
  )
)

```

### Server Logic
```{r}
# Define server logic ----
server2 <- function(input, output) {
  
  ##renders the plot according to the instructions below, which ggplot2() code supplies
  output$diseasePlot <- renderPlot({ 
    
    disease_state <- disease_data %>% filter(state == input$state) %>% filter(total_count > input$count) 
    ggplot(data = disease_state, mapping = aes(x = disease , y = total_count)) +
      geom_point(mapping = aes(color = state), size = 3) +
      theme_bw() +
      labs(x = "Contagious Disease",
           y = 'Total Case Count',
           title = 'Contagious diseases in the U.S. by state',
           caption = "Sources: The Tycho Project") +
      theme(axis.title = element_text(size= 14, face = 'italic', family = 'Verdana'),
            plot.title = element_text(size = 18, face = 'bold', family = 'Verdana'),
            plot.caption = element_text(size = 10, family= 'Verdana', hjust=0))
    
  })
}
```


### Run the App
```{r}
shinyApp(ui = ui2, server = server2)
```


## Example 3

### Data Processing 
```{r results='hide'}

library(stats)

```


### UI 
```{r}
ui3 <- fluidPage(
  
  titlePanel("Exploring Random Distributions"),
  
  sidebarLayout(
    sidebarPanel(
      helpText(h4("Select the variables to view in your visualization.")),
      
      #control widget that takes in number values within a selected range
      numericInput("pop1", label = "Population 1", value = 100, min = 1),
      numericInput("samp1", label = "Sample Size 1", value = 10, min = 1),
      br(),
      numericInput("pop2", label = "Population 1", value = 200, min = 1),
      numericInput("samp2", label = "Sample Size 1", value = 50, min = 1),
      br(),
    ),
    
    mainPanel(
      #function that displays plots
      plotOutput("hist1_eventReactive"),
      plotOutput("hist2_eventReactive")
    )
  )
)

```


### Server Logic

Shiny apps are special in that they can interact with users, respond to their input, and update their output quickly and seamlessly. But when programs get bigger and more complicated in terms of visual layout and computation, Shiny with its default settings can be very slow. 

Thus, **reactive expressions** can be used to control which parts of your app update and when, streamlining Shiny's output process and preventing unnecessary computation. 

This is how functions part of the **reactive()** family work:

* A reactive expression will saves its result the first time you run it.
* When the reactive expression is called again, it checks if the saved value (from the widget) has changed. 
* If it has changed, it will recompute only the part of the display that depends on it and save the new result.
* If the value hasn't changed, the reactive expression will not recompute and return its saved value.

```{r}
# Define server logic ----
server3 <- function(input, output, session) {
  
  ##eventReactive() is dependent only on the expressions inside the function and 
  # is called here to watch for the input values and update when necessary
  
  dist1_eventReactive <- eventReactive(c(input$pop1, input$samp1),
                                           {
                                             sample.int(input$pop1, input$samp1)
                                           })
  
  dist2_eventReactive <- eventReactive(c(input$pop2, input$samp2),
                                       {
                                         sample.int(input$pop2, input$samp2)
                                       })
  
  #Histograms are rendered here below through renderPlot()
  output$hist1_eventReactive <- renderPlot({
    
    dist1_data <- dist1_eventReactive()
    hist(dist1_data, col = 'dark blue', main = "Random Distribution 1")
  })
  
  output$hist2_eventReactive <- renderPlot({
    
    dist2_data <- dist2_eventReactive()
    hist(dist2_data, col = 'dark green', main = "Random Distribution 2")
  })
  
}
```


### Run the App
```{r}
shinyApp(ui = ui3, server = server3)
```



## Similar Packages
Packages similar to Shiny include: **Plotly**, **Lattice**, **RGL**, and **sunburstR**. However, the similarity of these packages depends on the user’s purpose for using Shiny to visualize the data. 

For starters, **Plotly** is a very common package in R that allows users to create interactive, high-quality graphs. The basic charts include scatter plots, line plots, bar charts, pie charts, bubble charts, and histograms. This package also has more scientific and financial graphs, such as log plots, contour plots, candlestick charts, and funnel charts. But, Plotly also offers so much more. You can use it to create various maps, like density maps, heat maps, and choropleth maps, as well as 3D charts. All of the graphs can be customized with the option of adding animations.

**Lattice** is another package that was created with the intent to help users visualize data. It offers similar graph and chart options as Shiny and Plotly, such as bar plots, histograms, and 3D scatterplots. Lattice was built using the grid package, and so it inherited an array of grid features. It was created with the intent of having better defaults as well as easily displaying multivariate relationships. Specifically, it helps identify the relationship between variables, conditioned on one or more of the variables.

Similar to Lattice, **RGL** was inspired by the grid package. It offers an extension to interactive 3D data visualization that Shiny lacks. The graphs can be customized by the 3D shape, lighting effects, options for the “materials” of the objects, and animation. 

Lastly, if the user is trying to depict sequences of events. Then, a package similar to Shiny is **sunburstR**. It is actually package that you can use with Shiny Events and Shiny Bindings using the functions “d2b-shiny” and “sund2b” respectively. One highlight of this package is that it displays percentages, which are used to overcome any distortion that may occur in the data when using a radial presentation. 

Overall, packages that are similar to Shiny depend on the *nature of a user’s data* as well as the *desire to personalize* the charts and graphs. 


## Reflection

Shiny is a very important package that should be utilized by data scientists to visualize and interact with data. As we show, Shiny can be used to create drop down options to interact with websites, and it can be used to manipulate graphs or charts. The possibilities are endless with the various features a user can customize. 

Our greatest criticism for Shiny is its inefficiency when updating data. If a user uses a large complex data set, then every time a user interacts with a chart the server refreshes all aspects of the code. This can create a lag. In turn, a slow performance can then disincetivize users from interacting with the data. 

In order to get around this issue, we needed to add a function for the "reactive" expression. This additional line of code specifies that we only want to update a specific portion of the output. Note, however, that this flaw can be solved and is only noticeable with large data sets and more complicated user interfaces/server objects and ShinyApp programs.

In all, the benefits to using Shiny far outweigh the inefficiencies. The interactive graphs are helpful in understanding the data at a deeper level. Once an output is created it is user friendly, and it can help tell a story that would not be possible with a static graphic or web page.

